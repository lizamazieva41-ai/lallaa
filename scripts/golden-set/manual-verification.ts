#!/usr/bin/env node
/**
 * Manual Verification Helper
 * Purpose: Sample N records from an existing golden set file and generate a review worksheet.
 *
 * This does NOT "verify" data automatically. It creates a reproducible list + template for a human
 * to verify against authoritative sources and document notes.
 *
 * Usage:
 *   npx ts-node scripts/golden-set/manual-verification.ts --input=data/golden-set/golden-set.json --count=200
 *
 * Outputs:
 *   data/golden-set/manual-verification-sample.json
 *   data/golden-set/manual-verification-notes.md
 */

import fs from 'fs';
import path from 'path';

type GoldenSetRecord = {
  bin: string;
  verifiedFields: {
    country: { value: string; sources: string[]; confidence: number };
    network: { value: string; sources: string[]; confidence: number };
    issuer: { value: string; sources: string[]; confidence: number };
    type: { value: string; sources: string[]; confidence: number };
  };
  verificationMethod: 'cross-source' | 'manual' | 'authoritative';
  lastVerified: string;
  verificationNotes?: string;
};

function parseArgs(argv: string[]): { input: string; count: number; seed: number } {
  const input =
    argv.find(a => a.startsWith('--input='))?.split('=')[1] || path.join('data', 'golden-set', 'golden-set.json');
  const count = parseInt(argv.find(a => a.startsWith('--count='))?.split('=')[1] || '200', 10);
  const seed = parseInt(argv.find(a => a.startsWith('--seed='))?.split('=')[1] || '1337', 10);
  return { input, count, seed };
}

function seededShuffle<T>(items: T[], seed: number): T[] {
  // Simple deterministic shuffle (LCG + Fisher-Yates)
  let s = seed >>> 0;
  const rand = (): number => {
    s = (1664525 * s + 1013904223) >>> 0;
    return s / 0xffffffff;
  };
  const arr = [...items];
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rand() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function main(): void {
  const { input, count, seed } = parseArgs(process.argv.slice(2));

  if (!fs.existsSync(input)) {
    throw new Error(
      `Golden set file not found: ${input}. Generate one first (e.g. scripts/golden-set/generate.ts) and place it under data/golden-set/.`
    );
  }

  const raw = fs.readFileSync(input, 'utf-8');
  const parsed = JSON.parse(raw);
  const records: GoldenSetRecord[] = Array.isArray(parsed)
    ? (parsed as GoldenSetRecord[])
    : Array.isArray(parsed?.records)
      ? (parsed.records as GoldenSetRecord[])
      : [];

  if (records.length === 0) {
    throw new Error(`Golden set contains 0 records: ${input}`);
  }
  const shuffled = seededShuffle(records, seed);
  const sample = shuffled.slice(0, Math.min(count, shuffled.length));

  const outDir = path.join(process.cwd(), 'data', 'golden-set');
  fs.mkdirSync(outDir, { recursive: true });

  const samplePath = path.join(outDir, 'manual-verification-sample.json');
  fs.writeFileSync(samplePath, JSON.stringify(sample, null, 2), 'utf-8');

  const notesPath = path.join(outDir, 'manual-verification-notes.md');
  const lines: string[] = [];
  lines.push('# Golden Set Manual Verification Notes');
  lines.push('');
  lines.push('This file is a human worksheet generated by `scripts/golden-set/manual-verification.ts`.');
  lines.push('');
  lines.push('## Instructions');
  lines.push('');
  lines.push('- Verify **each BIN** against 1+ authoritative sources (e.g., scheme network docs, issuer/bank sources, regulator lists).');
  lines.push('- Record **source URLs**, the verified value, and a short rationale.');
  lines.push('- If you confirm a mismatch, add a note describing which fields differ and why the golden value should be updated.');
  lines.push('');
  lines.push('## Sample');
  lines.push('');

  for (const r of sample) {
    lines.push(`### BIN ${r.bin}`);
    lines.push('');
    lines.push('- Expected (golden):');
    lines.push(`  - Country: ${r.verifiedFields.country.value} (conf=${r.verifiedFields.country.confidence})`);
    lines.push(`  - Network: ${r.verifiedFields.network.value} (conf=${r.verifiedFields.network.confidence})`);
    lines.push(`  - Issuer: ${r.verifiedFields.issuer.value} (conf=${r.verifiedFields.issuer.confidence})`);
    lines.push(`  - Type: ${r.verifiedFields.type.value} (conf=${r.verifiedFields.type.confidence})`);
    lines.push(`  - Sources: ${Array.from(new Set([ ...r.verifiedFields.country.sources, ...r.verifiedFields.network.sources, ...r.verifiedFields.issuer.sources, ...r.verifiedFields.type.sources ])).join(', ')}`);
    lines.push('');
    lines.push('- Verification (fill in):');
    lines.push('  - Authoritative sources (URLs):');
    lines.push('    - ');
    lines.push('  - Verified country: ');
    lines.push('  - Verified network: ');
    lines.push('  - Verified issuer: ');
    lines.push('  - Verified type: ');
    lines.push('  - Notes / rationale: ');
    lines.push('');
  }

  fs.writeFileSync(notesPath, lines.join('\n'), 'utf-8');

  // eslint-disable-next-line no-console
  console.log(`Manual verification sample generated:`);
  // eslint-disable-next-line no-console
  console.log(`- ${samplePath}`);
  // eslint-disable-next-line no-console
  console.log(`- ${notesPath}`);
  // eslint-disable-next-line no-console
  console.log(`Sample size: ${sample.length} (seed=${seed})`);
}

if (require.main === module) {
  main();
}

